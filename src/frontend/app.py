import logging
import streamlit as st
import asyncio
import aiohttp
import ssl
import threading
import json
import os
from src.common.spiffe import SpiffeHelper
from src.common.auth import JWTManager
from src.common.tracing import setup_tracing

# Configure Tracing & Logging
setup_tracing("frontend")
from opentelemetry import trace
logger = logging.getLogger("frontend")

print("DEBUG: STREAMLIT APP.PY EXECUTING")

# --- Page Config ---
st.set_page_config(page_title="Secure AI Agents", page_icon="üõ°Ô∏è")

# --- SPIFFE Initialization (Cached) ---
@st.cache_resource
def get_spiffe_helper():
    helper = SpiffeHelper()
    helper.start() # Blocks until SVID is ready
    return helper

try:
    spiffe = get_spiffe_helper()
    logger.info("Frontend: SPIFFE SVID Ready.")
except Exception as e:
    st.error(f"Failed to initialize SPIFFE Identity: {e}")
    st.stop()

# --- JWT & Auth Initialization ---
@st.cache_resource
def get_jwt_manager():
    # Read keys generated by the sidecar metadata server
    key_path = "/tmp/mesh_keys.json"
    import time
    # Wait for the file if necessary
    for _ in range(10):
        if os.path.exists(key_path):
            break
        time.sleep(1)
    
    with open(key_path, "r") as f:
        keys = json.load(f)
        return JWTManager(private_key_pem=keys["priv"], public_key_pem=keys["pub"])

jwt_manager = get_jwt_manager()

# --- Session State Initialization ---
if "user_token" not in st.session_state:
    st.session_state.user_token = None
    st.session_state.user_info = None
if "security_events" not in st.session_state:
    st.session_state.security_events = []
if "last_trace_id" not in st.session_state:
    st.session_state.last_trace_id = None

def add_security_event(msg, type="info"):
    icon = "‚ÑπÔ∏è"
    if type == "success": icon = "‚úÖ"
    elif type == "warning": icon = "‚ö†Ô∏è"
    elif type == "error": icon = "‚ùå"
    elif type == "lock": icon = "üîí"
    
    import datetime
    timestamp = datetime.datetime.now().strftime("%H:%M:%S")
    st.session_state.security_events.insert(0, f"[{timestamp}] {icon} {msg}")
    # Keep last 10
    st.session_state.security_events = st.session_state.security_events[:10]

def login():
    # Generate a Meshed JWT for the user
    user_id = "user_alice"
    email = "alice@example.org"
    token = jwt_manager.create_token(user_id, email)
    
    st.session_state.user_token = token
    st.session_state.user_info = {"email": email, "id": user_id}
    st.rerun()

def logout():
    st.session_state.user_token = None
    st.session_state.user_info = None
    st.rerun()

# --- Helper to Call Agents ---
async def call_agent(agent_host, endpoint, payload):
    url = f"https://{agent_host}:8080{endpoint}"
    
    # Get Client SSL Context (with my SVID)
    ssl_context = spiffe.get_client_ssl_context()
    
    # Add User Identity (JWT) to Request
    headers = {}
    if st.session_state.user_token:
        headers["Authorization"] = f"Bearer {st.session_state.user_token}"
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=payload, ssl=ssl_context, headers=headers) as resp:
                if resp.status == 200:
                    return await resp.json()
                else:
                    return {"status": "error", "code": resp.status, "text": await resp.text()}
    except Exception as e:
        return {"status": "error", "message": str(e)}

def verify_jws(token):
    """Verifies a signed response from an agent."""
    if not token: return None, "No signature"
    from authlib.jose import JsonWebSignature
    from authlib.common.encoding import urlsafe_b64decode
    import json
    
    jws = JsonWebSignature()
    try:
        # 1. Extract header manually to get cert chain (x5c)
        header_segment = token.split('.')[0].encode('utf-8')
        header = json.loads(urlsafe_b64decode(header_segment))
        
        x5c = header.get("x5c")
        if not x5c: return None, "Missing certificate chain"
        
        # 2. Verify with the public key from the first cert
        cert_pem = x5c[0]
        # deserialize_compact returns {'header': ..., 'payload': ...}
        jws.deserialize_compact(token, cert_pem)
        return header.get("kid"), "Valid Signature"
    except Exception as e:
        return None, f"Invalid: {str(e)}"

# --- UI Layout & Styling ---
st.markdown("""
    <style>
    .stApp {
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        color: #f8fafc !important;
    }
    p, h1, h2, h3, li, span, div {
        color: #f8fafc !important;
    }
    [data-testid="stSidebar"] {
        background-color: rgba(15, 23, 42, 0.9) !important;
        border-right: 1px solid #334155;
    }
    .security-badge {
        background-color: #0c4a6e;
        color: #38bdf8;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: bold;
        border: 1px solid #0ea5e9;
    }
    .status-ok { color: #4ade80; }
    .status-warning { color: #fbbf24; }
    .status-error { color: #f87171; }
    
    /* Glassmorphism for cards */
    .glass-card {
        background: rgba(30, 41, 59, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
    }
    </style>
""", unsafe_allow_html=True)

if not st.session_state.user_token:
    st.warning("Please authenticate (OAuth) to access the System.")
    if st.button("Login with Google (Mock)"):
        login()
else:
    user = st.session_state.user_info
    st.sidebar.success(f"Logged in as: {user['email']}")
    if st.sidebar.button("Logout"):
        logout()
        
    st.sidebar.divider()
    
    # --- Play 2: The Identity Inspector ---
    st.sidebar.subheader("üõ°Ô∏è Security Inspector")
    
    if "inspect_mode" not in st.session_state:
        st.session_state.inspect_mode = False
        
    st.session_state.inspect_mode = st.sidebar.toggle("Enable Deep Inspection", value=st.session_state.inspect_mode)
    
    if st.session_state.inspect_mode:
        # 1. Machine Identity (SPIFFE)
        with st.sidebar.expander("üåê Machine Identity (SPIFFE)", expanded=True):
            spiffe_id = spiffe.get_spiffe_id()
            st.markdown(f"**Identity:** `{spiffe_id}`")
            st.markdown(f"**Status:** <span class='status-ok'>‚úì Verified by SPIRE</span>", unsafe_allow_html=True)
            if st.button("View SVID Certificate", key="view_cert"):
                certs = spiffe.get_cert_chain_pems()
                st.code(certs[0], language="plaintext")
            st.caption("Auto-rotating every 1h via Workload API")

        # 2. Human Identity (JWT)
        with st.sidebar.expander("üë§ Human Identity (JWT)", expanded=True):
            if st.session_state.user_token:
                from authlib.jose import jwt
                decoded = jwt.decode(st.session_state.user_token, jwt_manager.public_key)
                st.markdown(f"**Subject:** `{decoded.get('sub')}`")
                st.markdown(f"**Email:** `{decoded.get('email')}`")
                st.json(decoded)
                st.markdown("**Signature:** <span class='status-ok'>‚úì RSA-256 Valid</span>", unsafe_allow_html=True)
                st.caption("Proof of Delegation: frontend ‚ûî researcher")
            else:
                st.info("No active JWT session")

        # 3. Observability (OTEL)
        with st.sidebar.expander("üì° Distributed Tracing (OTEL)", expanded=False):
            trace_id = st.session_state.get("last_trace_id", "No Active Trace")
            st.code(f"trace_id: {trace_id}", language="yaml")
            st.markdown("**Propagation:** `W3C TraceContext`")
            st.caption("Linking hops across the mesh")

        # 4. Content Integrity (JWS)
        with st.sidebar.expander("üîè Content Integrity (JWS)", expanded=True):
            last_resp = st.session_state.get("last_response", {})
            if "signature" in last_resp:
                agent_id, status = verify_jws(last_resp["signature"])
                st.markdown(f"**Researcher:** `{agent_id.split('/')[-1] if agent_id else 'Unknown'}`")
                st.markdown(f"**Integrity:** <span class='status-ok'>‚úì {status}</span>", unsafe_allow_html=True)
                
                writer_sig = last_resp.get("content", {}).get("writer_signature")
                if writer_sig:
                    w_agent_id, w_status = verify_jws(writer_sig)
                    st.markdown(f"**Writer:** `{w_agent_id.split('/')[-1] if w_agent_id else 'Unknown'}`")
                    st.markdown(f"**Integrity:** <span class='status-ok'>‚úì {w_status}</span>", unsafe_allow_html=True)
                
                if st.button("View Raw Payload"):
                    st.json(last_resp)
        # 5. Security Audit Log
        with st.sidebar.expander("üìù Security Audit Log", expanded=True):
            if st.session_state.security_events:
                for event in st.session_state.security_events:
                    st.caption(event)
            else:
                st.info("No security events recorded.")
    else:
        st.sidebar.info("Enable inspection to see Zero Trust metadata for active requests.")
    
    # Chat Interface
    if "messages" not in st.session_state:
        st.session_state.messages = []

    for msg in st.session_state.messages:
        with st.chat_message(msg["role"]):
            st.markdown(msg["content"])

    if prompt := st.chat_input("Ask me anything..."):
        # User Message
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)

        # Agent Response
        with st.chat_message("assistant"):
            message_placeholder = st.empty()
            message_placeholder.text("Authenticating & contacting Mesh...")
            
            # Prepare Payload with Identity Propagation
            payload = {
                "query": prompt,
                "user_id": user['id']
            }
            
            # Start a Tracing Span for this user interaction
            tracer = trace.get_tracer(__name__)
            with tracer.start_as_current_span("user_chat_interaction") as span:
                trace_id = format(span.get_span_context().trace_id, '032x')
                st.session_state.last_trace_id = trace_id
                add_security_event(f"Trace Context Initialized: {trace_id[:8]}...", "info")
                
                # Run Async Call in Sync Streamlit
                add_security_event(f"Requesting Researcher (mTLS + JWT)", "lock")
                response = asyncio.run(call_agent("researcher", "/ask", payload))
                st.session_state.last_response = response
            
            if response.get("status") == "success":
                add_security_event("Response Received (SVID Verified)", "success")
                data = response.get("content", {})
                answer = data.get("answer")
                verified_by = data.get("verified_caller")
                
                # Validate Signatures
                sig = response.get("signature")
                if sig:
                    agent_id, status = verify_jws(sig)
                    add_security_event(f"Researcher JWS Verified: {status}", "success")
                
                writer_sig = data.get("writer_signature")
                if writer_sig:
                    w_agent_id, w_status = verify_jws(writer_sig)
                    add_security_event(f"Writer JWS Verified: {w_status}", "success")

                full_reply = f"{answer}\n\n*üîí Verified Secure Connection from: {verified_by}*"
                message_placeholder.markdown(full_reply)
                st.session_state.messages.append({"role": "assistant", "content": full_reply})
            else:
                add_security_event("Agent Interaction Failed", "error")
                err_msg = f"‚ùå Agent Interaction Failed: {response}"
                message_placeholder.error(err_msg)
